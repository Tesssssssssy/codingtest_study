package week11.lim.week11_2.silver.n_1309.practice;

// 문제: https://www.acmicpc.net/problem/1309

import java.io.*;

public class Main {
    /**
     *  1. 가로 2칸 / 세로 N칸
     *  2. 가로와 세로로 붙어 있을 수 없다.
     *  3. 배치하는 경우의 수 출력
     *     (한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다.)
     *
     *  [생각]
     *  1. 격자의 크기에 사자를 배치하는데, 사자들은 인접할 수 없다.
     *     각 상태에서 가능한 선택을 반복하면서 최종 결과를 구해야 하는 구조이다.
     *  2. 큰 문제를 작은 문제로 나누는 것이 DP의 핵심.
     *     - 사자를 하나도 배치하지 않는 경우
     *     - 첫 번째 행에만 사자를 배치하는 경우
     *     - 두 번째 행에만 사자를 배치하는 경우
     *     => 이렇게 나누면 각 열마다 배치가 이전 열의 배치에만 의존하기 때문에
     *        각 열을 독립적인 작은 문제로 볼 수 있다.
     *  3. 이렇게 하면 문제를 해결할 때 반복되는 계산을 줄이고, 각 단계의 계산 결과를
     *     재활용하여 전체 문제의 해답을 구할 수 있다.
     *
     *  [풀이]
     *  - 3가지 경우의 수가 있기 때문에 각 행에 들어갈 수 있는 경우의 수를 저장할 배열 초기화
     *    -> dp[N][0]  /     dp[N][1]    / dp[N][2]
     *       사자 X     / 첫 번째 칸에만 있음 / 두 번째 칸에만 있음
     *
     *  - 그리고 초기 조건을 생각하면
     *    N = 1일 때,
     *      사자를 배치하지 않는 경우 1
     *      사자를 첫 행의 첫 번째 칸에 배치할 경우 1
     *      사자를 첫 행의 두 번째 칸에 배치할 경우 1
     *    => dp[1][0] = 1 / dp[1][1] = 1 / dp[1][2] = 1
     *
     *  - 이제 N = 2일 때를 생각하면, (두 번째 줄)
     *    사자를 배치하지 않는 경우 1
     *    사자를 첫 행의 첫 번째 칸에 배치할 경우 1
     *    사자를 첫 행의 두 번째 칸에 배치할 경우 1
     *    -> 고려해야할 조건은 똑같다. 하지만 가로, 세로에 사자를 붙어있게 할 수 없기 때문에
     *       두 번째 행에 배치하는 것에 따라 첫 행에 배치할 사자의 경우의 수가 제한된다.
     *    사자를 배치하지 않을 경우의 수는 여전히 dp[2][0] = 1이고
     *    사자를 첫 번째 칸에 배치한다면 (dp[2][1])
     *       1행의 첫 번째 칸과 2행의 두 번째 칸에 배치할 수 없다.
     *       -> 1행의 두 번째 칸과 2행의 첫 번째 칸에만 배치할 수 있는 것. (+ 1행에서 사자를 배치하지 않는 경우)
     *       => dp[2][1] = dp[1][0] + dp[1][2] = 1 + 1 = 2
     *
     *    사자를 두 번째 칸에 배치한다면 (dp[2][2])
     *       1행의 두 번째 칸과 2행의 첫 번째 칸에 배치할 수 없다.
     *       -> 1행의 첫 번째 칸과 2행의 두 번째 칸에만 배치할 수 있는 것. (+ 1행에서 사자를 배치하지 않는 경우)
     *       => dp[2][2] = dp[1][0] + dp[1][1] = 1 + 1 = 2
     *
     *    사자를 2행에도 배치하지 않는다면
     *       1행은 어떠한 제약도 받지 않는다.
     *       -> 1행에도 사자 배치 x + 1칸에 배치 + 2칸에 배치
     *       => dp[2][0] = dp[1][0] + dp[1][1] + dp[1][2]
     *
     *    그러면 이제 초기 조건까지 세웠으므로 위 과정을 바탕으로 점화식을 만들 수 있다.
     *    [점화식]
     *    dp[N][0] = dp[N-1][0] + dp[N-1][1] + dp[N-1][2]
     *    dp[N][1] = dp[N-1][0] + dp[N-1][2]
     *    dp[N][2] = dp[N-1][0] + dp[N-1][1]
     */
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());

        int[][] dp = new int[N+1][3];

        dp[1][0] = 1;
        dp[1][1] = 1;
        dp[1][2] = 1;

//        for (int i = 2; i <= N; i++) {
//            dp[i][0] = dp[i-1][0] + dp[i-1][1] + dp[i-1][2];
//            dp[i][1] = dp[i-1][0] + dp[i-1][2];
//            dp[i][2] = dp[i-1][0] + dp[i-1][1];
//        }
        /*
            모듈러 연산을 해서 저장하지 않으면 틀림.
            컴퓨터가 다룰 수 있는 숫자의 크기에 한계가 있기 때문.
            컴퓨터에서 정수 연산을 할 때, 사용할 수 있는 비트 수에 제한이 있어서 매우 큰 수를 다루는 데 한계가 있다.

            자바에서는 int 타입이 최대 2^31 − 1 (약 21억)까지의 값을 저장할 수 있고,
            long 타입은 2^63 − 1까지 저장할 수 있다.
            문제에서 주어진 N의 최댓값이 100,000이며, 사자의 배치 경우의 수는 매우 빠르게 증가할 수 있다.
            이런 상황에서 N이 큰 경우 중간 계산 값이 int 또는 long 범위를 초과하여 오버플로우가 발생할 수 있다.
        */

        for (int i = 2; i <= N; i++) {
            dp[i][0] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][2]) % 9901;
            dp[i][1] = (dp[i-1][0] + dp[i-1][2]) % 9901;
            dp[i][2] = (dp[i-1][0] + dp[i-1][1]) % 9901;
        }

        int result = (dp[N][0] + dp[N][1] + dp[N][2]) % 9901;

        System.out.println(result);
    }
}
