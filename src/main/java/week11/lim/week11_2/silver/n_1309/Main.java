package week11.lim.week11_2.silver.n_1309;

// 문제: https://www.acmicpc.net/problem/1309

import java.io.*;

public class Main {
    /**
     *  1. 가로 두칸, 세로 N칸인 동물원
     *  2. 사자들을 우리에 가둘 때, 가로/세로 모두 붙어 있게 배치할 수 없다.
     *  3. 2*N 배열에 사자를 배치하는 경우의 수가 몇 가지인지 출력.
     *  4. 사자를 한 마리도 배치하지 않는 경우도 하나로 친다고 가정.
     *  5. 사자를 배치하는 경우의 수를 9901로 나는 나머지 출력.
     *
     *  [풀이]
     *  동적 프로그래밍(Dynamic Programming) 기법
     *
     *  [고려]
     *  1. 사자가 배치되지 않는 경우
     *  2. 사자가 첫 번째 행에 배치되는 경우
     *  3. 사자가 두 번째 행에 배치되는 경우 등
     *
     *  [생각]
     *  dp[n][0] - n번째 열에서 사자를 하나도 배치하지 않는 경우의 수
     *  dp[n][1] - n번째 열에서 첫 번째 행에만 사자를 배치하는 경우의 수
     *  dp[n][2] - n번째 열에서 두 번째 행에만 사자를 배치하는 경우의 수
     *
     *  dp[1][0] = 1 (사자 없음)
     *  dp[1][1] = 1 (첫 번째 행에 사자 한 마리)
     *  dp[1][2] = 1 (두 번째 행에 사자 한 마리)
     *
     *  (1) 두 번째 줄에 동물을 놓지 않는 경우
     *  dp[2][0] 이 몇 인지 판단하는 케이스.
     *  그리고 이것은 dp[2][0] = dp[1][0] + dp[1][1] + dp[1][2] = 3 과 같다.
     *  두 번째 줄에 아무 동물도 놓지 않으면, 첫 번째 줄에는 어떠한 영향도 받지 않기 때문.
     *
     *  (2) 두 번째 줄의 첫 번째 칸에 동물을 놓는 경우
     *  dp[2][1] 이 몇 인지 판단하는 케이스.
     *  두 번째 줄의 첫 번째 칸에 동물을 놓게 되면, (1, 1) 과 (2, 2) 에는 동물을 놓을 수 없게 된다.
     *  따라서 dp[2][1] = dp[1][0] + dp[1][2] = 2 와 같다.
     *
     *  (3) 두 번째 줄의 두 번째 칸에 동물을 놓는 경우
     *  dp[2][2] 이 몇 인지 판단하는 케이스.
     *  두 번째 줄의 두 번째 칸에 동물을 놓게 되면, (1, 2) 와 (2, 1) 에는 동물을 놓을 수 없게 된다.
     *  따라서 dp[2][2] = dp[1][0] + dp[1][1] = 2 와 같다.
     *
     *  (1) ~ (3) 에 따라, 2 x 2 공간에서 동물을 놓을 수 있는 경우의 수는 7 이 된다.
     *  그리고 이를 일반화하여 점화식을 아래와 같이 표현할 수 있다.
     *
     *  [점화식]
     *  dp[n][0] = dp[n-1][0] + dp[n-1][1] + dp[n-1][2]
     *  dp[n][1] = dp[n-1][0] + dp[n-1][2]
     *  dp[n][2] = dp[n-1][0] + dp[n-1][1]
     *
     *  최종적으로 구해야 할 값은 N번째 열까지 고려했을 때의 모든 경우의 수의 합이므로
     *  결과 = dp[N][0] + dp[N][1] + dp[N][2]
     *
     *  이 모든 값을 9901로 나눈 나머지로 출력.
     */
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());

        int[][] dp = new int[N+1][3];

        // 초기 값 설정
        dp[1][0] = 1;
        dp[1][1] = 1;
        dp[1][2] = 1;

        // DP 배열 채우기
        for (int i = 2; i <= N; i++) {
            dp[i][0] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][2]) % 9901;
            dp[i][1] = (dp[i-1][0] + dp[i-1][2]) % 9901;
            dp[i][2] = (dp[i-1][0] + dp[i-1][1]) % 9901;
        }

        // 결과 계산
        int result = (dp[N][0] + dp[N][1] + dp[N][2]) % 9901;

        // 출력
        System.out.println(result);
    }
}
