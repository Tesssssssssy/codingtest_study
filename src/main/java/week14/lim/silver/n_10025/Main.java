package week14.lim.silver.n_10025;

// 문제: https://www.acmicpc.net/problem/10025

import java.io.*;
import java.util.*;

public class Main {
    /**
     *  더운 여름날 동물원의 백곰 앨버트는 너무 더워서 꼼짝도 하기 싫다.
     *  다행히도 사육사들이 앨버트의 더위를 식히기 위해 얼음이 담긴 양동이들을 가져다 주었다.
     *  앨버트가 가장 적은 거리만 움직이고도 최대한 많은 얼음으로 더위를 식힐 수 있도록 도와주자.
     *
     *  우리 안은 1차원 배열로 생각하며,
     *  총 N(1 ≤ N ≤ 100000)개의 얼음 양동이들이 xi(0 ≤ xi ≤ 1,000,000)좌표마다 놓여 있고
     *  각 양동이 안에는 gi(1 ≤ gi ≤ 10,000)씩의 얼음이 들어 있다.
     *
     *  일단 앨버트가 자리를 잡으면 그로부터 좌우로 K(1 ≤ K ≤ 2,000,000) 만큼 떨어진 양동이까지 닿을 수 있다.
     *  앨버트는 양동이가 놓여 있는 자리에도 자리잡을 수 있다.
     *  모든 얼음 양동이의 위치는 다르다.
     *
     *  앨버트가 최적의 자리를 골랐을 때 얼음의 합을 구하시오. 즉, 얼음들의 합의 최댓값을 구해야 한다.
     *
     *  [입력]
     *  첫 줄에 정수 N과 K가 들어온다. 둘째 줄부터 N째 줄까지, 공백을 사이에 두고 각 양동이의 얼음의 양을 나타내는 gi와 양동이의 좌표를 나타내는 xi가 주어진다.
     *
     *  [출력]
     *  앨버트가 택한 최적 위치로부터 K만큼 떨어진 거리 내에 있는 얼음들의 합(최댓값)을 출력한다.
     *
     *  [풀이]
     *  슬라이딩 윈도우
     */
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(st.nextToken());
        int K = Integer.parseInt(st.nextToken());

        // 좌표의 범위는 최대 1,000,000까지
        int[] ice = new int[1000001];

        // 얼음 양과 좌표 입력 처리
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            int gi = Integer.parseInt(st.nextToken());
            int xi = Integer.parseInt(st.nextToken());
            ice[xi] += gi;
        }

        // 슬라이딩 윈도우 초기화
        int maxIce = 0;
        int currentSum = 0;
        int windowSize = 2 * K + 1;

        // 초기 윈도우의 합 계산
        for (int i = 0; i < windowSize && i < 1000001; i++) {
            currentSum += ice[i];
        }
        maxIce = currentSum;

        /*
            목표: 초기 윈도우를 오른쪽으로 한 칸씩 이동시키면서, 각 위치에서의 얼음 합을 계산하고,
            그 중 최대값을 찾아 maxIce에 저장
        */
        for (int i = windowSize; i < 1000001; i++) {
            /*
                코드가 실행되기 전에, 이미 처음 윈도우(맨 처음 2K + 1 범위의 얼음들)의 합이 currentSum에 저장되어 있다.
                이 윈도우는 배열의 시작 부분에서 시작.
            */

            currentSum += ice[i];
            /*
                현재 윈도우의 오른쪽 끝에 있는 ice[i]를 currentSum에 추가.
                이는 새로운 위치에서의 합에 최신 요소를 더하는 것.
            */

            currentSum -= ice[i - windowSize];
            /*
                이제 윈도우가 한 칸 오른쪽으로 이동했으므로, 이전 윈도우의 첫 번째 요소를 빼준다.
                이는 더 이상 이 윈도우의 범위에 포함되지 않는 요소.
            */

            maxIce = Math.max(maxIce, currentSum);
            // currentSum이 이전에 기록된 maxIce보다 크다면, maxIce를 갱신하여 더 큰 얼음 합을 기록.
        }

        System.out.println(maxIce);
    }
}
/*
    접근 방법
        1차원 배열 준비
            얼음 양동이가 놓인 위치를 고려하여 1차원 배열을 준비.
            배열의 인덱스는 각 좌표를 나타내고, 값은 해당 좌표에 있는 얼음의 양을 나타냄.

        슬라이딩 윈도우
            앨버트가 특정 위치에 자리잡았을 때, 그로부터 K 거리만큼 떨어진 좌우 범위 내에 있는 얼음의 양을 슬라이딩 윈도우 기법으로 계산.
            윈도우의 크기는 2K + 1이며, 이 윈도우를 좌우로 이동하면서 최대 얼음 양을 찾는다.

        최대값 갱신
            각 윈도우의 합을 계산하면서, 그 값이 최대가 되도록 갱신.
*/
/*
    코드 설명
        배열 초기화
            ice[1000001] 배열은 각 좌표에서의 얼음 양을 저장.
            주어진 좌표 xi에 gi만큼의 얼음을 추가.

        슬라이딩 윈도우 초기화
            windowSize는 앨버트가 닿을 수 있는 좌우 범위를 포함하는 윈도우의 크기 (2 * K + 1).
            초기 윈도우(처음 windowSize 크기만큼의 범위)에서의 얼음 양을 합산하여 currentSum에 저장.

        슬라이딩 윈도우 이동
            윈도우를 한 칸씩 오른쪽으로 이동하면서, 윈도우 내 얼음의 합을 계산하고, maxIce를 갱신.

        결과 출력
            최대 얼음 합 maxIce를 출력.

        시간 복잡도
            배열의 크기는 최대 1,000,000이므로,
            이 접근법은 O(1,000,000)의 시간 복잡도로 문제를 효율적으로 해결할 수 있다.
            이 코드는 주어진 문제의 조건을 충족하며,
            최적의 위치에서 앨버트가 모을 수 있는 최대 얼음 양을 계산.
*/
/*
    윈도우 사이즈가 2K + 1이 되는 이유
        문제 이해
            앨버트가 특정 위치에 자리잡은 후,
            좌우로 K만큼 떨어진 거리 내에 있는 모든 양동이에 닿을 수 있다.
            이 말은 앨버트가 있는 위치를 기준으로 왼쪽으로 K만큼,
                                         오른쪽으로 K만큼의 거리에 있는
                                         모든 양동이들을 포함한 구간 내의 얼음의 합을 계산해야 한다는 의미.

        슬라이딩 윈도우의 크기 계산
            앨버트의 위치를 중심으로 좌우로 K만큼 떨어진 거리를 포함해야 한다.
            예를 들어, 앨버트가 좌표 xi에 자리잡고 있다고 가정하면,
                앨버트는 xi - K부터 xi + K까지의 범위에 있는 양동이에 닿을 수 있다.
                이 범위를 포함하는 윈도우의 길이는 (xi + K) - (xi - K) + 1이 된다.
                이를 간단히 정리하면 2K + 1이 된다.

        정리
            윈도우 크기는 앨버트가 특정 위치에서 최대한 멀리 닿을 수 있는 범위의 전체 길이이다.
            따라서 윈도우 크기는 2K + 1이 된다.
            이 크기만큼의 범위를 한 번에 고려하여 그 범위 내의 얼음 합을 계산하고, 윈도우를 이동시키며 최적의 위치를 찾는다.

        예를 들어, K = 3일 경우
            앨버트는 특정 위치에서 왼쪽으로 3, 오른쪽으로 3, 총 7개의 위치를 커버할 수 있다.
            따라서 윈도우 크기는 7 (2 * 3 + 1 = 7)이 된다.
*/